/* TODO
   - NULL events - they cause multiple transitions subsequently
   - what about generated states - for now ignored
   - what about conditions - for now ignored
   - dependency management using require.js
   - given a state a method that returns the path starting from the initial state
   - parallel states 
   - final state
*/
(function(global, factory) {
    if (typeof module === 'object') {
        var logger,
            defer,
            messageBus;
        logger = require('umd-logger');
        defer = require('jquery-deferred').Deferred();
        messageBus = require('message-bus');       
        module.exports = factory(logger, defer, messageBus);
    } else if (typeof define === 'function' && define.amd) {
        // TODO
        define([''], factory);
    } else {
        global.pathgen = global.pathgen || {};
        pathgen.generator = factory(window.umd_logger, $.Deferred(), window.MessageBus);
    }
})(this, function(console, _defer, MessageBus) {
    var _instance = null;
    var newInstance = function(engine, player) {
        var paths = [],
            // util = engine.scion,
            event,
            visited,
            _paths = [],
            _events,
            _result;
        var print = (function() {
            for (var i = 0; i < this.length; i++) {
                console.log(this[i]);
            }
        });
        var start = function() {
            event = "";
            visited = [];
            paths = [];
            _paths = [];
            _events = [];
            paths.str = print;
            _paths.str = print;
            _result = {};
            // restart the engine
            engine.start();
            // clear saved path of the recorder
            player.rec.path = [];
            update();
            return _defer.promise();
        };
        var update = function() {
            MessageBus.remove('transitionFinished', update, _instance);
            var todo,
                done,
                path,
                i,
                currentState = engine.getStateId();

            console.debug('check current state', currentState, engine.getStateName());
            // create new paths if state has not been already visited or is generated by scion
            if (visited.indexOf(currentState) === -1 && currentState.substr(0, 1) !== "$") {
                todo = engine.getActiveEvents();
                done = player.rec.path.slice();
                if (event) done.push(event);
                visited.push(currentState);
                _result[currentState] = {
                    pathes: done,
                    type: engine.getStateTypeById(currentState),
                    name: engine.getStateNameById(currentState)
                };
                for (i = 0, len = todo.length; i < len; i++) {
                    path = done.slice();
                    path.push(todo[i]);
                    paths.push(path);
                    _paths.push(path.slice());
                }
            }
            if (paths.length === 0) {
                console.debug('###################################################');
                console.debug('### SIMULATION IS FINISHED ###');
                console.debug('ALL PATHS:');
                console.debug(_paths.str());
               for (i = 0, len = _events.length; i < len; i++) {
                    console.debug(JSON.stringify(_events[i]));
                }
                console.debug('###################################################');
                _defer.resolve({
                    data: _result,
                    scion: engine
                });
                return;
            }
            console.debug(_paths.str());
            // path to the target event
            path = paths.splice(0, 1)[0];
            // next targeted event to be simulated 
            event = path.pop();
            MessageBus.register('playbackFinished', next, _instance);
            if (!engine.isInitialDefaultState(engine.getStateId())) {
                // restart the engine if not residing in the initial default state 
                engine.start();
            }
            // clear saved path of the recorder    
            player.rec.path = [];
            // start recorder
            player.rec.start();
            // fire events in the path subsequently

            console.debug('###################################################');
            var getSize = function(obj) {
                var size = 0, key;
                for (key in obj) {
                    if (obj.hasOwnProperty(key)) size++;
                }
                return size;
            };            
            console.debug('#########', getSize(_result), 'COLLECTED PATHS', '#########');
            // console.debug(_result);
            console.debug('SIMULATE PATH', path, 'WITH EVENT:', event);
            console.debug('##################', paths.length, 'PATHS LEFT ##################');
            // for (var i = 0; i < paths.length; i++) {
            //     console.debug(paths[i]);
            // }
            console.debug('###################################################');
            player.play(path);
        };
        var next = function() {
            MessageBus.register('transitionFinished', update, _instance);
            setTimeout(function(context) {
                var sie = {};
                sie[engine.getStateId()] = event;
                _events.push(sie); // debuggin_paths.str()g
                console.debug('###################################################');
                console.debug('########### FIRE EVENT: ' + event + ' #############');
                console.debug('###################################################');
                engine.raise(event);
                //player.play(event);
                // this.update();
            }, 10, this);
        };

        return {
            start: start,
            pause: function() {
                player.pause();
            },
            stop: function() {
                player.stop();
            }
        };
    };
    console.debug("load: generator");
    return {
        init: function(engine, simulator) {
            if (engine) {
                if (_instance) {
                    return _instance;
                } else {
                    _instance = newInstance(engine, simulator);
                    // scxml.simulator = _instance;
                    return _instance;
                }
            } else if (!engine) {
                if (_instance) {
                    return _instance;
                } else {
                    console.warn('instance of simulator as param');
                    return;
                }
            }
        },
    };
});
